# Copyright 2019, Hudson and Thames Quantitative Research
# All rights reserved
# Read more: https://hudson-and-thames-arbitragelab.readthedocs-hosted.com/en/latest/additional_information/license.html

"""
Tests function of Multivariate Cointegration module:
cointegration_approach/multi_coint.py
"""

import os
import unittest

import numpy as np
import pandas as pd
import statsmodels.api as sm

from arbitragelab.cointegration_approach.multi_coint import MultivariateCointegration


class TestMultivariateCointegration(unittest.TestCase):
    """
    Test Multivariate Cointegration module.
    """

    def setUp(self):
        """
        Set up the data and parameters.

        Data: AEX, DAX, CAC40, and FTSE100 data from Jan 1st 1996 to Dec 31st 2006.
        """

        # Read data.
        project_path = os.path.dirname(__file__)
        data_path = project_path + '/test_data/multi_coint.csv'
        self.data = pd.read_csv(data_path, parse_dates=['Date'])
        self.data.set_index("Date", inplace=True)

        # Split the data into in-sample and out-of-sample subset.
        trade_date = pd.Timestamp(2001, 11, 6)
        self.train_data = self.data.loc[:trade_date]
        self.trade_data = self.data.loc[trade_date:]

    def test_calc_log_price_ffill(self):
        """
        Test the calculation of log prices with forward-fill missing data imputation.
        """

        # Test missing data forward fill imputation.
        ffill_test = MultivariateCointegration(self.data, None)

        # Test if the price dataframe has been properly read.
        self.assertEqual(len(ffill_test.asset_df), 2836)

        nan_date1 = pd.Timestamp(1997, 10, 3)
        nan_date2 = pd.Timestamp(1999, 4, 30)
        nan_date3 = pd.Timestamp(1999, 5, 31)
        nan_date4 = pd.Timestamp(2000, 6, 12)

        # Do missing data imputation.
        ffill_test.calc_log_price(nan_method='ffill')

        # See if the forward filling algorithm worked properly.
        self.assertAlmostEqual(ffill_test.asset_df.loc[nan_date1]['DAX'], 4266.17)
        self.assertAlmostEqual(ffill_test.asset_df.loc[nan_date2]['AEX'], 573.52)
        self.assertAlmostEqual(ffill_test.asset_df.loc[nan_date3]['FTSE'], 6226.22)
        self.assertAlmostEqual(ffill_test.asset_df.loc[nan_date4]['CAC'], 6549.05)

    def test_calc_log_price_spline(self):
        """
        Test the calculation of log prices with cubic spline missing data imputation.
        """

        # Test missing data cubic spline imputation.
        spline_test = MultivariateCointegration(self.data, None)

        # Do missing data imputation.
        spline_test.calc_log_price(nan_method='spline', order=3)

        nan_date1 = pd.Timestamp(1997, 10, 3)
        nan_date2 = pd.Timestamp(1999, 4, 30)
        nan_date3 = pd.Timestamp(1999, 5, 31)
        nan_date4 = pd.Timestamp(2000, 6, 12)

        # See if the forward filling algorithm worked properly.
        self.assertAlmostEqual(spline_test.asset_df.loc[nan_date1]['DAX'], 4266.639227962006)
        self.assertAlmostEqual(spline_test.asset_df.loc[nan_date2]['AEX'], 572.7939563445334)
        self.assertAlmostEqual(spline_test.asset_df.loc[nan_date3]['FTSE'], 6231.123973566768)
        self.assertAlmostEqual(spline_test.asset_df.loc[nan_date4]['CAC'], 6483.287118123764)

    def test_calc_log_price_error(self):
        """
        Test the calculation of log prices with erroneous input.
        """

        # Test missing data but with wrong parameters.
        error_test = MultivariateCointegration(self.data, self.trade_data)

        # Raise ValueError.
        self.assertRaises(ValueError, error_test.calc_log_price, 'ignore')

    def test_calc_log_price_result(self):
        """
        Test the results of log price calculation.
        """

        # Use ffill to test as it is faster.
        result_test = MultivariateCointegration(self.data, None)

        # Do missing data imputation and log price calculation.
        result_test.calc_log_price(nan_method='ffill')

        result_test_sample = result_test.log_asset_df.tail(1)

        self.assertAlmostEqual(result_test_sample['AEX'].values[0], 6.205244395469226)
        self.assertAlmostEqual(result_test_sample['DAX'].values[0], 8.794358152425072)
        self.assertAlmostEqual(result_test_sample['FTSE'].values[0], 8.73565540233506)
        self.assertAlmostEqual(result_test_sample['CAC'].values[0], 8.620067418819382)

    def test_fit_sig_level_error(self):
        """
        Test the exception generated by inputting a wrong significance level.
        """

        # Initialize the trading signal generator.
        fit_test = MultivariateCointegration(self.data, None)

        # Provide a wrong parameter.
        self.assertRaises(ValueError, fit_test.fit, sig_level='91%')

    def test_fit_no_rolling_window(self):
        """
        Test the cointegration vector fitting procedure with all available data.
        """

        # Initialize the trading signal generator.
        roll_window = MultivariateCointegration(self.data, None)

        # Use all data, no rolling window.
        no_rw_coint_vec = roll_window.fit(nan_method='ffill', rolling_window_size=None)

        self.assertAlmostEqual(no_rw_coint_vec['AEX'], 3.905186528497843)
        self.assertAlmostEqual(no_rw_coint_vec['DAX'], 13.59504820164842)
        self.assertAlmostEqual(no_rw_coint_vec['FTSE'], -21.908546878682)
        self.assertAlmostEqual(no_rw_coint_vec['CAC'], -4.642046206684594)

    def test_fit_rolling_window(self):
        """
        Test the cointegration vector fitting procedure with rolling window of 1,500 days.
        """

        # Initialize the trading signal generator.
        roll_window = MultivariateCointegration(self.data, None)

        # Use all data, no rolling window.
        rw_coint_vec = roll_window.fit(nan_method='ffill', rolling_window_size=1500)

        self.assertAlmostEqual(rw_coint_vec['AEX'], 4.096651742116751)
        self.assertAlmostEqual(rw_coint_vec['DAX'], -19.41801830323376)
        self.assertAlmostEqual(rw_coint_vec['FTSE'], 45.98640603614171)
        self.assertAlmostEqual(rw_coint_vec['CAC'], -13.476049682084337)

    def test_fit_not_coint(self):
        """
        Test the cointegration vector fitting procedure with price series that are not cointegrated.
        """
        np.random.seed(0)
        # Simulate an asset price with AR(1) dynamics.
        asset1 = sm.tsa.ArmaProcess(ar=np.array([1, -0.95])).generate_sample(500) + 1
        asset1 = 100 + np.cumsum(asset1)

        # Simulate another asset price with different AR(1) dynamics.
        asset2 = sm.tsa.ArmaProcess(ar=np.array([1, -0.75])).generate_sample(500) + 0.3
        asset2 = 100 + np.cumsum(asset2)

        # Simulate an asset price with AR(2) dynamics.
        asset3 = sm.tsa.ArmaProcess(ar=np.array([1, -0.55, -0.15])).generate_sample(500) + 0.05
        asset3 = 100 + np.cumsum(asset3)

        # Fit and catch the warning.
        no_coint_data = pd.DataFrame(np.vstack((asset1, asset2, asset3)).T)
        no_coint = MultivariateCointegration(no_coint_data, None)
        with self.assertWarnsRegex(Warning, 'trace'):
            no_coint.fit(sig_level="99%", rolling_window_size=None)
        with self.assertWarnsRegex(Warning, 'eigen'):
            no_coint.fit(sig_level="99%", rolling_window_size=None)

    def test_num_of_shares(self):
        """
        Test the calculation of number of shares to trade.
        """

        # Find the cointegration vector, calculate the trading signal, i.e. the number of shares.
        num_of_shares_test = MultivariateCointegration(self.data, None)
        num_of_shares_test.fit(nan_method='ffill', rolling_window_size=None)

        # Default trading position is 10,000,000 currency
        pos_shares, neg_shares = num_of_shares_test.num_of_shares()

        # Check if the share numbers are correct.
        self.assertEqual(pos_shares.values[0], -4504)
        self.assertEqual(pos_shares.values[1], -1177)
        self.assertEqual(neg_shares.values[0], 1326)
        self.assertEqual(neg_shares.values[1], 315)

        # Verify if the positions are dollar-neutral.
        last_price = num_of_shares_test.asset_df.iloc[-1]
        neg_pos = pd.concat([last_price, neg_shares], axis=1).dropna()
        neg_pos_dollar_value = neg_pos.iloc[:, 0] @ neg_pos.iloc[:, 1]

        pos_pos = pd.concat([last_price, pos_shares], axis=1).dropna()
        pos_pos_dollar_value = pos_pos.iloc[:, 0] @ pos_pos.iloc[:, 1]

        # Rounding error will always cause positions not exactly dollar neutral.
        # As long as it is close to neutral it should be passing the test.
        self.assertTrue(abs(neg_pos_dollar_value + pos_pos_dollar_value) / 1.e7 < 5.e-4)

    def test_trade_signal(self):
        """
        Test trading signal generation.
        """

        # Initialize two trading signal generator. Short one do not trigger a cointegration vector update.
        trade_signal_test = MultivariateCointegration(self.train_data, self.trade_data.iloc[:110, :])
        trade_signal_short_test = MultivariateCointegration(self.train_data, self.trade_data.iloc[:21, :])

        # Generate trading signals
        signals, coint_vec_time_evo = trade_signal_test.trading_signal(30, rolling_window_size=None)
        _, coint_vec_time_evo_short = trade_signal_short_test.trading_signal(15, rolling_window_size=None)

        # Check the shape of signal and cointegration vector evolution dataframe
        self.assertTupleEqual(signals.shape, (110, 4))
        self.assertTupleEqual(coint_vec_time_evo.shape, (110, 4))

        # Check the value of the calculation results. Check head and tail.
        self.assertListEqual(list(signals.iloc[0].values), [20740.0, -610.0, -1245.0, -144.0])
        self.assertListEqual(list(signals.iloc[-1].values), [19624.0, -609.0, -1190.0, -169.0])
        self.assertListEqual(list(coint_vec_time_evo.iloc[0].values),
                             [30.507755593162194, -12.048910113397362, -27.2487683546217, -2.6950408603345077])
        self.assertListEqual(list(coint_vec_time_evo.iloc[-1].values),
                             [31.07014821383982, -13.140996130452553, -25.550218022060093, -3.1229310063460174])

        # If cointegration vector is not updated, then the cointegration vector should be the same for each data point.
        self.assertTrue(np.isclose(coint_vec_time_evo_short['AEX'], coint_vec_time_evo_short['AEX'].mean()).all())
        self.assertTrue(np.isclose(coint_vec_time_evo_short['FTSE'], coint_vec_time_evo_short['FTSE'].mean()).all())
        self.assertTrue(np.isclose(coint_vec_time_evo_short['CAC'], coint_vec_time_evo_short['CAC'].mean()).all())
        self.assertTrue(np.isclose(coint_vec_time_evo_short['DAX'], coint_vec_time_evo_short['DAX'].mean()).all())
